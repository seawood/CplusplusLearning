[TOC]

-----------------------------------------
# C++函数调用的压栈过程
- 三个相关的寄存器：EBP存储当前栈帧的基地址，ESP存储当前栈帧的栈顶地址，EIP存储要执行的下一条指令的地址
- 入栈：实参-》当前EIP值（返回地址）-》当前EBP值（保存上一个栈帧的基地址即EBP，然后将ESP的值赋给EBP，此时EBP指向当前栈帧的基地址）-》局部变量
- 出栈：将EBP值赋给ESP，以此弹出局部变量，将EBP指向内存中存储的值赋给EBP使得EBP指向调用函数栈底，然后弹出存储的EIP值给EIP，ESP继续上移，弹出调用参数
![f1b6ab002af634348f66b17868d1abdf.png](en-resource://database/1722:0)

# 指针和引用的区别

| 不同点 | 指针  |引用  |
| --- | --- | --- |
| 独立存储空间 |有，指针是变量  | 无，引用是原有变量的别名 |
| const |有const指针  |无const引用  |
|多级  |有多级指针  |&&为右值引用  |
| 空 | 可以为空 |不能为空，且必须在定义时初始化  |
| 初始化后改变 | 可以 | 不能 |
|sizeof| 指针本身的大小| 引用所指向变量的大小|
| ++ | 地址递增 | 所指向变量的值递增 |
| 作为函数参数| 传递的是地址的拷贝，可以改变实参 | 传递的是实参本身，可以改变实参 |

## 引用是否可以实现动态绑定

## 函数返回引用类型
- 不能返回局部变量的引用，因为函数返回后，局部变量会被销毁
- 返回函数内部new分配的内存的引用，容易造成内存泄漏。比如函数返回的引用只是作为一个临时变量，没有赋予一个实际的变量；或者在函数外部忘记了这个引用指向的是一个由new分配的内存，忘记了调用delete。
- 可以返回类成员的引用，但最好是返回const引用。

# 堆和栈的区别
| 不同点 | 栈 | 堆 |
| --- | --- | --- |
|程序的内存分配| 由编译期自动分配和释放，存放函数的参数值、局部变量等，栈区向地址减小的方向生长，分配速度快，操作方式类似于数据结构中的栈 | 由程序员分配和释放，若程序不释放，程序结束时由OS回收；分配速度慢，地址不连续，容易碎片化；分配方式类似于链表 |
| 数据结构 | 连续存储，先进后出 | 分连续的树形存储结构，经过排序，根节点最小/大，常用来实现优先级队列 |

# new和malloc的区别
![44dcc700fa7bef6b9771340dc7cc2d81.png](en-resource://database/1622:1)

# C和C++的区别与联系
| 不同点 | C  |C++  | 备注 |
| --- | --- | --- | --- |
|思想 | 面向过程 | 可以很好地进行面向对象的程序设计 | 但C++也不是完全的面向对象，还有泛型编程等；C++对C的增强体现在下面几个方面 |
| 类型检查机制 | void* 指向不同对象，使用时强制类型转换，绕过了编译器的类型检查 | 使用基类指针或引用代替void* | |
| 面向对象 | 结构体只可以封装数据 | 结构体可以封装数据和对应的操作 ，有类 | |
| 模板 | 无 | 比类和函数更高层次的抽象，并且提供了STL | |
| 异常处理 | 不提供对错误处理的直接支持,一般通过函数返回值和错误代码errno查看错误 |  提供了一系列标准的异常，定义在<exception> | |
| 函数重载 | 不支持 | 支持 | |
| 动态管理内存的方式 | malloc/free | 增加了new和delete| |
| 引用 | 无 | 有 | |
| 输入输出 | stdio库函数 | 增加了iostream类库| |

# 四种强制类型转换
- static_cast：任何具有明确定义的转换，只要不包含底层const，都可以使用static_cast。常用：将一个较大的算数类型赋值给一个较小的类型；将void* 指针转换成具体的指针类型。
- const_cast:去掉对象的const属性，常量去掉const之后执行写操作会产生未定义的行为。主要用在函数参数传递上(函数重载上很有用）。
 ![08449b5c740e7b2eb358240f8236fe6b.png](en-resource://database/1710:1)
![a994421752c1358cc047044b22581616.png](en-resource://database/1712:1)

- reinterpret_cast:为运算对象的位模式提供较低层次上的重新解释，比如将一个int* 转换成一个char*, 非常危险，避免使用。
- dynamic_cast:用于运行时类型识别，具体来说是将基类的指针或者引用安全地转换成派生类的指针或者引用。主要用在想通过基类指针调用派生类的一个非虚函数。

>
> dynamic_cast<type * >(e)出错返回0
> dynamic_cast(type &>(e) e必须是左值，出错返回bad_cast
> dynamic_cast(type &&>(e) e不能是左值

# struct相关
## 内存对齐
> 内存对齐的作用：内存对齐是编译期采用的一种优化手段，在牺牲一定存储空间的前提下提高速度。比如32位机器，一次传输4字节，4字节对齐能够使CPU访问速度提高，此时一个8字节的long型数据，CPU要取两次，同样的即使是一个4字节的数据，如果没有内存对齐也需要CPU取两次。

- 结构体的首地址是结构体内最宽基本数据类型成员大小的整数倍
- 结构体内每个成员相对于结构体首地址的偏移量是该成员大小的整数倍，否则在成员之间填充字节
- 结构体的大小是结构体内最宽基本数据类型成员大小的整数倍，否则在结构体尾部填充字节


## struct和class的区别

- struct的默认访问权限是public，class的默认访问权限是private。当然好的编程习惯应该是显示地表明访问权限。
- class继承默认是private继承，struct继承默认是public继承。struct可以继承class,class也可以继承struct，默认的继承访问权限看子类是struct还是class。
## struct和union的区别
- struct中所有成员变量都存在，所占用内存大小为所有成员变量大小之和（考虑内存对齐）；union中同时只能存在一个成员变量，所占用内存大小为最大的成员长度（考虑内存对齐）。


# const相关
## const的作用
- 可以修饰变量、函数返回值、函数参数、类的成员函数，不可变性
- 便于编译期做类型安全检查，比如函数void f(const int a),不能在函数中修改变量a的值
- 保护被修饰的东西，防止被意外修改，增强程序健壮性
- 将常值替换成一个const变量，可以便于修改，类似宏定义，一变则全部变
- 节省空间，避免不必要的内存分配。const定义的常量在程序运行过程中只有一个复制品，而#define定义的常量在内存中有多个复制品。从汇编的角度看，const给出的是内存地址，#define给出的是立即数。


```cpp
#define PI 3.14
const double Pi=3.1413; //未分配内存
double i=Pi;  //为Pi分配内存
double j=PI；//编译期间进行宏替换，分配内存
double ii =Pi; //没有内存分配
double jj=PI; //再次分配内存
```
- 提高效率，编译期不为普通的const常量分配存储空间，而是将他们保存在符号表中。？

## 基于const的函数重载
- 类成员函数
```cpp
class A {
    void f(int i) {  }
    void f(int i) const {  }//上一个函数的重载，被const 的A类对象调用
    }
 const A A2;
 A2.f(); //调用void f(int i) const
```

- const修饰函数参数，仅但const修饰的是引用或者指针的时候，才允许基于const的函数重载

```cpp
void f(const int& a);
void f(int& a);
```
```cpp
//错误
void f(const int a);
void f(int a);
```
## const指针
- `const int* a` 和`int const * a` const修饰指向的对象，a可变，a指向的对象不可变
- `int* const a`修饰指针a,a不可变，a指向的对象可变
- `const int* const a`指针和指向的对象都不可变

## 临时变量是const类型的
- 可以用一个临时变量初始化const引用类型，而不能用一个临时变量初始化非const引用类型
```cpp
void bar(string &s);
bar("hello");//错误，产生一个临时对象，不能用临时对象初始化非const引用类型
```

# define相关
## #define和const的区别
- 类型安全：#define在预处理阶段进行替换，不具有类型安全，const在编译阶段会进行类型安全检查
- 内存占用：const定义的常量在程序运行过程中只有一个复制品，而#define定义的常量在内存中有多个复制品。从汇编的角度看，const给出的是内存地址，#define给出的是立即数。


## #define和typedef的区别
 - #define和typedef都可以用来定义类型别名，#define还可以用来定义常量、编译开关等
 - #define在预处理阶段替换，typedef在编译阶段处理
 - typedef有作用域限制，而#define没有，只要之前预定义过的宏，在以后的程序中都可以使用
 - 在类中定义的宏还有访问权限限制
 - 二者修饰指针类型时，作用不同
 ![0757581cf399adfcd48856e75d939494.png](en-resource://database/1668:1)
 
 # static相关
 ## static的用法
 - static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。
- C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。 静态数据成员定义时要分配空间，所以不能在类声明中定义。静态成员函数没有this指针，不能访问非静态成员函数和非静态成员变量。出现在类体外的静态成员函数和静态成员变量定义不需要加static关键字。
- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
- 未初始化时，static变量默认值为0。

## 在头文件中定义static变量是否可行
这样会使得每个包含该头文件的源文件中都定义一个静态变量，并不是真正的全局变量（如果本意是想定义全局变量的话，是错误的用法），引起空间浪费。

# STL相关
## unordered_map和map的区别
> unordered_map的插入过程：得到key的hash值，hash值对桶的数量取模得到桶号，将key和value存放在桶内。
- 存储结构：map采用红黑树存储（有序二叉树）；unordered_map采用hash表存储，并不是有序的。
- 构造函数：因为map是有序存储，需要比较元素之间的大小，所以需要指定operator<;unordered_map存储时需要根据key的hash值判断两个元素是否相等，因此需要指定hash_value函数和operator==。（当然对于内置类型来说，都自带了这些函数，不需要用户自己指定）
- 查找速度：map的查找速度是O(log(n)),unordered_map的查找速度是O(1)

# 面向对象的三大特性
## 封装

## 继承

## 多态：虚函数和动态绑定
>多态是指接口多种不同实现方式，虚函数和动态绑定是C++中实现多态的方法。

- 基类中用virtual修饰的函数为虚函数，子类中同名、参数相同的函数自动成为虚函数（即使没有virtual）。
- 虚函数定义时不需要加virtual关键字。
- 非类的成员函数、类的静态函数、构造函数不能定义为虚函数。析构函数一般定义为虚函数。
- 虚函数用于在运行阶段动态地选择合适的函数（动态绑定），基类指针指向子类对象，调用的是子类的虚函数实现。
- 虚函数的实现：定义了虚函数的类有一个虚函数表，该表是个一维数组，存放的是每个虚函数的地址；类的对象有一个指向虚函数表的指针，这个指针指向对象所属类的虚函数表。
- 纯虚函数：virtual f(int a)=0;父类没有提供纯虚函数的实现，父类不能被实例化，是一种接口继承，子类必须提供实现。

> 构造函数不能定义为虚函数的原因：
> - 没有必要：定义虚函数是为了在运行时根据类型选择合适的函数进行调用，但是构造函数是被主动调用的，而且调用顺序是固定的，先调用基类的构造函数，再调用子类的构造函数。
> - 实现方面：调用虚函数需要虚函数表指针，虚函数表指针是在构造函数中被初始化的，所以在调用构造函数之前虚函数表指针还是没有被初始化，因此无法调用虚函数。

> 析构函数为什么要定义为虚函数：用基类指针指向子类对象时，如果析构函数没有被定义为虚函数，调用的是基类的析构函数，那么子类的部分就不能被析构；如果析构函数定义为虚函数，那么就会根据动态绑定调用子类的析构函数，子类的析构函数里会首先析构子类部分、再析构父类部分。

# C++内存管理
## 三种内存区
- 堆：使用new创建的对象，需要程序员负责内存管理（delete）
- 栈：自动变量、临时对象，由系统自动进行内存管理
- 静态存储区：静态对象、全局对象


## 如何禁止产生堆对象
- 产生堆对象的方法是调用new,而operator new是可以重载的，因此只要将operator new和operator delete声明为private就可以禁止产生堆对象。（operator new的主要作用是搜索可用的地址）


## 确保在函数抛出异常时堆对象被正确释放内存
- 在栈对象中封装资源：在栈对象的构造函数中new,在栈对象的析构函数中delete，因为即使抛出异常，栈对象的析构函数也会被自动调用，因此可以确保抛出异常时堆对象被正确释放。

## C++垃圾回收（？）
https://blog.csdn.net/wallwind/article/details/6889917

# 静态链接和动态链接
- 程序在链接阶段对共享库的链接方式分为静态和动态两种，对应的可以将共享库分为静态库和动态库。静态库（.a和.lib）,动态库（.so和.dll）
>库文件：一系列目标文件（.o）的集合,将多个目标文件压缩到一起，并且对其进行编号和索引，以便查找和检索。
- 静态链接：在链接阶段把静态库链接到目标代码中，在运行时就不需要这个静态库了，因此生成的可执行文件比较大，而且静态库如果有更新要重新编译
- 动态链接：在链接阶段不把动态库链接到目标代码，只是记录下对共享库的依赖关系，动态库在运行时载入，因此运行时需要该动态库的存在，好处是可以共享动态库，对于动态库的升级比较方便

# 关键字
## extern
- 声明变量或者函数，表示变量或者函数的定义在别的文件中

```cpp
// A.h
extern int a;
//A.cpp
int a=1;
//B.cpp
#include "A.h"
int b = a;
```

## switch
- 后面接的表达式要是整数表达式，int,short,char,枚举类型都可以，long,string,char[]就不行。

## volatile
> CPU(控制器+运算器+寄存器)->cache->主存->外部存储器
 - 易变性：下一条语句中使用的volatile变量不能直接从寄存器中缓存的volatile变量取，要从内存中取
 - 不可优化性：禁止编译期对volatile变量进行优化，保证写在代码中的指令一定会被执行
 - 顺序性：不同volatile变量间的操作不会被编译期交换顺序，但是volatile和非volatile变量间的操作可能会被编译期交换顺序。（这在volatile变量和非volatile变量同时存在的多线程环境下可能会有问题，因此要结合锁来使用）

```cpp
char* volatile a; //修饰的是指针
volatile char* b;//修饰的是指针指向的变量
```

## export
- C++的分离编译模式：允许在一个编译单元中定义变量、函数等，在另一个编译单元中引用它们的声明就可以使用这些已定义的变量、函数等。这是通过关键字extern实现的，编译器在处理完所有编译单元之后，链接器接下来处理所有指向extern符号的引用，从而生成一个可执行的文件。
- 但是标准要求模板在实例化时必须在上下文中可以查看到其定义实体，因此模板的定义和实例化要放在同一个编译单元。export用于支持模板分离编译模式。
![03ef3bb61cd4c9d784ea5686baef81dc.png](en-resource://database/1704:1)
- 但是由于export会使得性能很差，因此一般将模板的定义放在头文件中。
![81b7a57e5275e9651689d6f606ac2305.png](en-resource://database/1706:1)

## explicit
- 用于只有一个参数或者除了第一个参数外其他参数都有默认值的类构造函数，用于禁止隐式转换
![ac27c61612dbd3ee92dddfab17d41c38.png](en-resource://database/1708:1)

# 拷贝相关

## 深拷贝和浅拷贝
- 浅拷贝：增加了一个指针，指向原来已经存在的内存
- 深拷贝：增加了一个指针，同时这个指针指向一块新申请的内存，这个内存上存的值和原来的已经存在的内存上存的值一样

### 重载赋值运算符函数
```cpp
#ifndef MY_STRING
#define MY_STRING
class MyString{
public:
    MyString& operator=(const MyString& mystring) {
        if(this != &mystring) {
            MyString tmp(mystring);
            char* data = tmp.m_data;
            tmp.m_data = m_data;
            m_data = data;
        }
        return *this;
    }
private:
    char* m_data;
};
#endif
```
## 零拷贝（emplace_back）
###  左值和右值
> 左值有持久的状态，右值是字面常量或者表达式求职过程中创建的临时变量。

### 对象移动
> 使用移动而不是拷贝的两个原因：有些对象在被拷贝之后就立即被销毁，因此移动比拷贝更合理；IO类或者 unique_ptr这样的类不能被共享，不能被拷贝但可以移动。

### 右值引用
> 必须绑定到右值的引用。可以将一个右值绑定到const左值引用。

### std::move函数
> 将对象的所有权从一个对转移到另一个对象
```cpp
string s = "hello";
vector<string> v;
v.push_back(std::move(s)); //移动之后，不要再使用s
```

### 移动构造函数和移动赋值运算符


# 智能指针

##  RAII机制（资源获取即初始化）
- 智能指针是一种RAII技术，智能指针是一种模板类，封装了普通的指针，在它的析构函数里执行对普通指针所指向内存的释放。当智能指针对象离开作用域时，它的析构函数会被自动调用，因此普通指针所指向的内存也会被自动释放。
- 这使得程序员不用担心忘记释放指针所指向的内存、或者发生异常导致内存没有被正确释放。

 ## 三种智能指针
 - unique_ptr：独占语义，只能转移所有权，不能拷贝和复制构造
 - shared_ptr：引用计数语义，引用计数减为0时，相应的内存才被释放。有循环引用问题
 - weak_ptr：为了配合shared_ptr而引入的一种智能指针，它不具有普通指针的行为（没有重载* 和->）。它的构造不会造成对应内存引用计数加1，可以从shared_ptr或者weak_ptr构造。它像观测者一样观测资源的使用情况，use_count（）、expired()用于检查内存的引用计数，lock()函数返回一个可用的shared_ptr对象，从而可以操纵资源。
 ## shared_ptr的循环引用问题
>  导致内存泄漏，没有访问这两块内存的方法，但是这两块内存还存在。基于引用计数的智能指针之间的引用链成环就会导致这个问题，解决方法是在引用链的一方改用weak_ptr。

### 循环引用
 ![cf5c0a227f6d786cc394e448c6ad9f45.png](en-resource://database/1688:1)

 ![cd593a9c299fb0e5d8442b87d9d44295.png](en-resource://database/1684:1)
 
 ### 用weak_ptr解决循环引用
 ![c95eb68cb1d9f52a702adc5a60f94940.png](en-resource://database/1694:1)
 
 ![b2b16ec50652f604f6743fa1fc9b80a9.png](en-resource://database/1690:1)
 ![9c6eddba90d9a7cda5776a267af200d2.png](en-resource://database/1692:1)
 
 